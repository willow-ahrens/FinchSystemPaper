
\section{The Finch Language}

\subsection{Syntax}

The syntax of Finch is displayed in Figure \ref{fig:syntax}. The Finch syntax
mirrors most imperative languages with for-loops and control flow. Notable
inclusions to the language include \mintinline{julia}{for},
\mintinline{julia}{let}, blocks of code with \mintinline{julia}{if}, and 
the lifecycle functions that let us declare, freeze, and thaw tensors.

Finch uses looplets to lower \mintinline{julia}{for}-loops, though a sparse
program with complicated looplets should produce output tensors with the same
semantic value as a dense program with ordinary for-loops.  We include the
semantics of how looplets are lowered as it affects the structure of the results
and the asymptotic complexity of the program. Some applications view the
structure of tensors as semantically meaningful.

The \mintinline{julia}{let} statement (marked by the \finchdefine AST node)
allows us to define tensor variables and reuse their value in multiple
subexpressions without passing the variable through a tensor. Although it is too
complex in this work to propagate constants through tensors, we can propagate
constants (including 0) through a define statement. This allows the compiler to
build up complicated functions of known operators and infer annihilation
properties through them.It also allows use to eliminate common subexpressions,
or tensor accesses, by reusing a tensor value in multiple places (such as the
symmetric spmv in Figure \ref{fib:spmv_programs}). As another example, in the
following program we don't need to define sparsity and annihilator properties of
$f(a + b) * (a - b)$, as we can derive this from the more basic operators, and
the code only reads from $A$ and $B$ once.
\begin{minted}{julia}
    let a = A[i, j]
        let b = B[i, j]
            C[i, j] = (a + b) * (a - b)
        end
    end
\end{minted}

We allow the use of blocks of code to describe multiple operations. This allows
us to support both multiple outputs and temporary tensors, seen most prominently
in our implementation of gustavson's algorithm for sparse-sparse matrix multiply
and breadth-first-search. Our breadth-first seach also uses an
\mintinline{julia}{if} statement to avoid operating on vertices outside the
frontier. We have found that \mintinline{julia}{if} is particularly useful in
our model for masking to avoid work.

Finally, we add some explicit functions to advance the lifecycle of a tensor.
Note that the user would not typically write \mintinline{julia}{@freeze} or
\mintinline{julia}{@thaw} explicitly as those can be inferred through a separate
pass.

\begin{figure}
\scriptsize
\noindent % This ensures the minipages fill the page width
\begin{minipage}{0.4\linewidth}
\begin{align*}
    \finchliteral(val \in \mathbb{V}) &:= \text{\mintinline{julia}{val}} \\
    \finchvalue(ex \in \mathbb{S}, type \in \mathbb{T}) &:= \text{\mintinline{julia}{ex :: type}} \\
    \finchtensor(name \in \mathbb{S}) &:= \text{\mintinline{julia}{name}} \\
    \finchindex(name \in \mathbb{S}) &:= \text{\mintinline{julia}{name}} \\
    \finchvar(name \in \mathbb{S}) &:= \text{\mintinline{julia}{name}} \\
    \finchextent(a \in E, b \in E) &:= \text{\mintinline{julia}{a : b}} \\
    \finchcall(f \in E, args\ldots \in E) &:= \text{\mintinline{julia}{f(args...)}} \\
    \finchaccess(tns \in T, idxs\ldots \in E) &:= \text{\mintinline{julia}{tns[idxs...]}} \\
    \finchfreeze(tns \in T) &:= \text{\mintinline{julia}{@freeze(tns)}} \\
    \finchthaw(tns \in T) &:= \text{\mintinline{julia}{@thaw(tns)}} \\
    \finchmode(tns \in T) &:= \text{\mintinline{julia}{@mode(tns)}} \\
\end{align*}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{align*}
    \mathbb{V} &:= \text{the set of all values.} \\
    \mathbb{S} &:= \text{the set of all symbols.} \\
    \mathbb{T} &:= \text{the set of all types.} \\
    I &:= \finchindex \\
    A &:= \finchaccess \\
    V &:= \finchvar \\
    T &:= \finchtensor \\
    E &:= \finchliteral \mid \finchvalue \mid \finchindex \\
        &\quad \mid \finchvar \mid \finchextent \mid \finchcall \mid \finchaccess \\
    S &:= \finchassign \mid \finchloop \mid \finchdefine \\
        &\quad \mid \finchsieve \mid \finchblock \\
\end{align*}
\end{minipage}%
\begin{align*}
    \finchdeclare(tns \in T, init \in E, dims\ldots \in E) &:= \text{\mintinline{julia}{tns .= init(dims...)}} \\
    \finchassign(lhs \in A, op \in E, rhs \in E) &:= \text{\mintinline{julia}{lhs <<op>>= rhs}} \\
    \finchloop(idx \in I, range \in E, body \in S) &:= \text{\mintinline{julia}{for idx = range; body end}} \\
    \finchdefine(var \in V, val \in E, body \in S) &:= \text{\mintinline{julia}{let var = val; body end}} \\
    \finchsieve(cond \in E, body \in S) &:= \text{\mintinline{julia}{if cond; body end}} \\
    \finchblock(bodies\ldots \in S) &:= \text{\mintinline{julia}{begin; bodies... end}}
\end{align*}
\caption{The syntax of the finch language. Note that instead of a classic EBNF
form, we have constrained the classes of subterms on the left hand side to allow
for descriptive names of the arguments. Compare this grammar to the Concrete
Index Notation of TACO \cite[Figure~3]{kjolstad_tensor_2019}, noting the
addition of multiple left hand sides through code blocks, and the explicit
initialization and finalization of tensors.}\label{fig:syntax}
\end{figure}

\subsection{Semantics}

We present a sketch of a small-step operational semantics, showing how to execute a Finch program in a host language.
We break our description of the semantics of Finch into three parts, those
relating to lowering the language itself in Figure~\ref{fig:semantics_core},
those pertaining to the lifecycle of tensors in
Figure~\ref{fig:semantics_lifecycle}, and the semantics of the looplets in
Figure~\ref{fig:semantics_looplets}. Note that in addition to the rules seen
here, we also apply extensive symbolic simplification of the program whenever we
can. In the implementaiton of the language we have heuristics for when to run a
simplification pass, but for the purposes of understanding the semantics of the
language we should understand simplification rules as occuring whenever possible
before continuing to execute the program as normal.

Note that both Looplets and Finch are designed to be embedded into a larger
language, and a separate state variable is introduced for this language.  

%What are values? (objects in the host language)
%What is t really? (

\begin{figure}
    \centering
    \footnotesize

    \begin{prooftree}
    \hypo{\langle val, (e, t) \rangle
    \rightarrow val'}
    \infer1[$Define$]{\splitfrac{\langle\finchdefine(var, val, body), (e, t)\rangle}{\rightarrow \langle body, (e[var \mapsto val'], t) \rangle}}
    \end{prooftree}
    \hfill
    \begin{prooftree}
        \hypo{\langle args_i, (e, t) \rangle \Rightarrow vals_i}
        \hypo{\langle f, (e, t) \rangle \Rightarrow g}
        \infer2[$Call$]{\langle\finchcall(f, args...), (e, t)\rangle \rightarrow \langle g(vals...), t \rangle}
    \end{prooftree}
    \vspace{12pt}

    \begin{prooftree}
        \hypo{}
        \infer1[$Literal$]{\langle\finchliteral(val), (e, t)\rangle \rightarrow val}
    \end{prooftree}
    \hfill
    \begin{prooftree}
        \hypo{}
        \infer1[$Value$]{\langle\finchvalue(ex, type), (e, t)\rangle \Rightarrow \langle ex, t \rangle}
    \end{prooftree}
    \vspace{12pt}

    \begin{prooftree}
        \infer0[$Variable$]{\splitfrac{\langle\finchvar(name), (e, t)\rangle}{\rightarrow e(\finchvar(name))}}
    \end{prooftree}
    \hfill
    \begin{prooftree}
        \infer0[$Index$]{\splitfrac{\langle\finchindex(name), (e, t)\rangle}{\rightarrow e(\finchindex(name))}}
    \end{prooftree}
    \vspace{12pt}

    \begin{prooftree}
        \hypo{\langle head, s_1 \rangle \rightarrow s_2}
        \infer1[$BlockHead$]{\langle\finchblock(head, tail...), s_1 \rangle \rightarrow \langle \finchblock(tail...), s_2 \rangle}
    \end{prooftree}
    \hfill
    \begin{prooftree}
        \infer0[$EmptyBlock$]{\langle\finchblock(), s\rangle \rightarrow s}
    \end{prooftree}
    \vspace{12pt}

    \begin{prooftree}
        \hypo{\langle cond, s \rangle \Rightarrow true}
        \infer1[$SieveTrue$]{\langle\finchsieve(cond, body), s\rangle \rightarrow \langle body, s \rangle}
    \end{prooftree}
    \hfill
    \begin{prooftree}
        \hypo{\langle cond, s \rangle \Rightarrow false}
        \infer1[$SieveFalse$]{\langle\finchsieve(cond, body), s\rangle \rightarrow s}
    \end{prooftree}
    \vspace{12pt}
    
    \begin{prooftree}  
    \hypo{s = (e, t)}
    \hypo{e(tns) = tns'}
    \hypo{\langle init, s \rangle \Rightarrow init'}
    \hypo{\forall i \langle init, dims_i \rangle \Rightarrow dims'_i}
    \hypo{\langle declare(tns', init', dims'...), t \rangle \rightarrow t'}
    \infer5[$Declare$]{\langle \finchdeclare(tns, init, dims), (e, t)\rangle \rightarrow (e [\finchmode(tns) \mapsto update], t')}
    \end{prooftree}
    \vspace{12pt}
    
    \begin{prooftree}  
    \hypo{s = (e, t)}
    \hypo{e(\finchmode(tns)) = update}
    \hypo{e(tns) = tns'}
    \hypo{\langle freeze(tns'), t \rangle \rightarrow t'}
    \infer3[$Freeze$]{\langle\finchfreeze(tns), (e, t)\rangle \rightarrow (e [\finchmode(tns) \mapsto read], t')}
    \end{prooftree}
    \vspace{12pt}

    \begin{prooftree}  
    \hypo{s = (e, t)}
    \hypo{e(\finchmode(tns)) = read}
    \hypo{e(tns) = tns'}
    \infer3[$Thaw$]{\langle\finchthaw(tns), s\rangle \rightarrow (e [\finchmode(tns) \mapsto update], \langle thaw(tns'), t \rangle)}
    \end{prooftree}
    
    \caption{Basic evaluation semantics, roughly defining most of these language
    constructs to function similarly to their classical definitions. Note that
    The state $s$ of the finch compiler is a tuple $(e, t)$ of a variable value
    environment and another state $t$ corresponding to the state in the
    host language. Several Looplets introduce variables into the embedding
    language, which may be read when evaluating the \finchvalue node.
    %
    The state $s$ of the finch compiler
    is a tuple $(e, t)$ of a variable value environment and another state $t$
    corresponding to the state in the host language.
    This means that rules which modify $t$ are running in the host language. All of the lifecycle
    functions are designed to be implemented and executed in the host language,
    but these semantics enforce that each of these functions may update state in
    the host language and flip the mode of the tensor between read and update}
    \label{fig:semantics_core}
\end{figure}


\begin{figure}
    \centering
    \footnotesize

\vspace{12pt}

\begin{prooftree}
    \infer0[$Run$]{\splitfrac{\langle \finchloop(i, ext, E[\finchaccess(run(body), j..., i)]), s\rangle}{\rightarrow \langle \finchloop(i, ext, E[\finchaccess(body, j...)]), s\rangle}}
\end{prooftree}
\hfill
\begin{prooftree}
    \hypo{e(i) = i'}
    \hypo{\langle seek(i'), t \rangle \rightarrow t'}
    \infer2[$Lookup$]{\splitfrac{\langle E[\finchaccess(lookup(seek, body), j..., i)], (e, t)\rangle}{\rightarrow \langle E[\finchaccess(body, j...)], (e, t')\rangle}}
\end{prooftree}
\vspace{12pt}

\begin{prooftree}
    \hypo{\langle cond, t \rangle \Rightarrow true}
    \infer1[]{\splitfrac{\langle E[\finchaccess(switch(cond, head, tail), i...)], s\rangle}{\rightarrow \langle E[\finchaccess(head, i...)], s\rangle}}
\end{prooftree}
\hfill
\begin{prooftree}
    \hypo{\langle cond, t \rangle \Rightarrow false}
    \infer1[$Switch$]{\splitfrac{\langle E[\finchaccess(switch(cond, head, tail), i...)], s\rangle}{\rightarrow \langle E[\finchaccess(tail, i...)], s\rangle}}
\end{prooftree}
\vspace{12pt}

\begin{prooftree}
    \infer0[$Phase$]{\splitfrac{\langle \finchloop(i, extent(a, b), E[\finchaccess(phase(extent(c, d), body), j..., i)]), s\rangle}{\rightarrow \langle \text{\finchloop}(i, extent(max(a, c), min(b, d)), E[\text{\finchaccess}(body, j..., i)]), s\rangle}}
\end{prooftree}
\vspace{12pt}

\begin{prooftree}
    \hypo{\langle \finchloop(i, ext, E[\finchaccess(head, j..., i)]), s\rangle \rightarrow s'}
    \infer1[$Sequence$]{\splitfrac{\langle \finchloop(i, ext, E[\finchaccess(sequence(head, tail), j..., i)]), s\rangle}{\rightarrow \langle \finchloop(i, ext, E[\finchaccess(tail, j..., i)]), s'\rangle}}
\end{prooftree}
\hfill
\begin{prooftree}
    \hypo{\langle node, algebra \rangle \rightarrow node'}
    \infer1[$Simplify$]{\langle E[node], s\rangle \rightarrow \langle E[node'], s\rangle}
\end{prooftree}
\vspace{12pt}

\begin{prooftree}
    \hypo{\langle seek(a), t \rangle \rightarrow t'}
    \infer1[$StepperSeek$]{\splitfrac{\langle \finchloop(i, extent(a, b), E[\finchaccess(stepper(seek, body, next), j..., i)]), (e, t)\rangle}{\rightarrow \langle \finchloop(i, extent(a, b), E[\finchaccess(stepper(body, next), j..., i)]), (e, t')\rangle}}
\end{prooftree}
\vspace{12pt}

\begin{prooftree}
    \hypo{\langle \finchloop(i, ext, E[\finchaccess(body, j..., i)]), (e, t) \rangle \rightarrow (e', t')}
    \hypo{\langle next, t' \rangle \rightarrow t''}
    \infer2[$StepperNext$]{\splitfrac{\langle \finchloop(i, ext, E[\finchaccess(stepper(body, next), j..., i)]), s\rangle}{\rightarrow \langle \finchloop(i, ext, E[\finchaccess(stepper(body, next), j..., i)]), (e', t'')\rangle}}
\end{prooftree}


    \caption{Looplet evaluation semantics. 
    The state $s$ of the finch compiler is a tuple $(e, t)$ of a variable value
    environment and another state $t$ corresponding to the state in the host
    language. This means that rules which modify $t$ are running in the host language. Note that $E$ is an evaluation context that applies anywhere in
    the syntax tree. The nonlocal evaluations of Looplets are what allow looplets to
    hoist conditions and subranges out of loops. However, this also means we must specify
    the priority in which we apply looplet rules, which is as follows:
    $Phase > Switch > Simplify > Run > Spike > Sequence > StepperSeek > StepperNext > Lookup$
    Many looplets, most notably the thunk looplet, introduce variables into the
    host language environment.  While variables introduced by a looplet may be
    modified by the looplet itself (steppers often increment some state
    variables), we forbid child looplets from modifying any state variables that
    they didn't introduce. This allows us to treat the \finchvalue node as a
    constant.
    %
    Note: the $Simplify$ rule references $algebra$, which is our variable
    defining a set of straightforward simplification rules. These rules include
    simple properties like $x * 0 \rightarrow 0$ to more complicated ones such
    as constant propagation. We omit the full set of rules for brevity, but
    point the curious reader to \cite[Figure 5]{ahrens_looplets_2023} for some examples}
    \label{fig:semantics_looplets}
\end{figure}


