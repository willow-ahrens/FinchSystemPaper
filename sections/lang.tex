
\section{The Finch Language}

\subsection{Syntax and Semantics}

\noindent % This ensures the minipages fill the page width
\begin{minipage}{0.4\linewidth}
\begin{align*}
    \finchliteral(val \in \mathbb{V}) &:= \text{\mintinline{julia}{val}} \\
    \finchvalue(ex \in \mathbb{S}, type \in \mathbb{T}) &:= \text{\mintinline{julia}{ex :: type}} \\
    \finchtensor(name \in \mathbb{S}) &:= \text{\mintinline{julia}{name}} \\
    \finchindex(name \in \mathbb{S}) &:= \text{\mintinline{julia}{name}} \\
    \finchvar(name \in \mathbb{S}) &:= \text{\mintinline{julia}{name}} \\
    \finchextent(a \in E, b \in E) &:= \text{\mintinline{julia}{a : b}} \\
    \finchcall(f \in E, args\ldots \in E) &:= \text{\mintinline{julia}{f(args...)}} \\
    \finchaccess(tns \in T, idxs\ldots \in E) &:= \text{\mintinline{julia}{tns[idxs...]}} \\
    \finchfreeze(tns \in T) &:= \text{\mintinline{julia}{@freeze(tns)}} \\
    \finchthaw(tns \in T) &:= \text{\mintinline{julia}{@thaw(tns)}} \\
    \finchmode(tns \in T) &:= \text{\mintinline{julia}{@mode(tns)}} \\
\end{align*}
\end{minipage}%
\begin{minipage}{0.5\linewidth}
\begin{align*}
    \mathbb{V} &:= \text{the set of all values.} \\
    \mathbb{S} &:= \text{the set of all symbols.} \\
    \mathbb{T} &:= \text{the set of all types.} \\
    I &:= \finchindex \\
    A &:= \finchaccess \\
    V &:= \finchvar \\
    T &:= \finchtensor \\
    E &:= \finchliteral \mid \finchvalue \mid \finchindex \\
        &\quad \mid \finchvar \mid \finchextent \mid \finchcall \mid \finchaccess \\
    S &:= \finchassign \mid \finchloop \mid \finchdefine \\
        &\quad \mid \finchsieve \mid \finchblock \\
\end{align*}
\end{minipage}%
\begin{align*}
    \finchdeclare(tns \in T, init \in E, dims\ldots \in E) &:= \text{\mintinline{julia}{tns .= init(dims...)}} \\
    \finchassign(lhs \in A, op \in E, rhs \in E) &:= \text{\mintinline{julia}{lhs \texttt{<<op>>=} rhs}} \\
    \finchloop(idx \in I, range \in E, body \in S) &:= \text{\mintinline{julia}{for idx = range; body end}} \\
    \finchdefine(var \in V, val \in E, body \in S) &:= \text{\mintinline{julia}{let var = val; body end}} \\
    \finchsieve(cond \in E, body \in S) &:= \text{\mintinline{julia}{if cond; body end}} \\
    \finchblock(bodies\ldots \in S) &:= \text{\mintinline{julia}{begin; bodies... end}}
\end{align*}

the state $s$ of the finch compiler is a tuple $(e, t)$ of a variable value
environment and another state $t$ corresponding to the embedding language.



\[
    \frac{}{\langle\finchliteral(val), (e, t)\rangle \rightarrow val} \quad
    \frac{}{\langle\finchvalue(ex, type), (e, t)\rangle \Rightarrow \langle ex, t \rangle} \quad
\]
\[
    \frac{}{\langle\finchvar(name), (e, t)\rangle \rightarrow e(\finchvar(name))} \quad
    \frac{}{\langle\finchindex(name), (e, t)\rangle \rightarrow e(\finchindex(name))}
\]
\[
    \frac{\langle args_i, (e, t) \rangle \Rightarrow vals_i \quad \langle f, (e, t) \rangle \Rightarrow g}
    {\langle\finchcall(f, args...), (e, t)\rangle \rightarrow \langle g(vals...), t \rangle}
\]
\[
\frac{\langle head, s_1 \rangle \rightarrow s_2}
{\langle\finchblock(head, tail...), s_1 \rangle \rightarrow \langle \finchblock(tail...), s_2 \rangle} \quad
\frac{}{\langle\finchblock(), s\rangle \rightarrow s}
\]
\[
\frac{\langle cond, s \rangle \Rightarrow true}
{\langle\finchsieve(cond, body), s\rangle \rightarrow \langle body, s \rangle}\quad
\frac{\langle cond, s \rangle \Rightarrow false}
{\langle\finchsieve(cond, body), s\rangle \rightarrow s}
\]
\[
\frac{\langle val, (e, t) \rangle \rightarrow val'}
{\langle\finchdefine(var, val, body), (e, t)\rangle \rightarrow \langle body, (e[var \mapsto val'], t) \rangle}
\]
\[
\frac{s = (e, t) \quad e(\finchmode(tns)) = read \quad e(tns) = tns' \quad  \langle init, s \rangle \rightarrow init' \quad  \langle dims_i, s \rangle \rightarrow dims_i'}
{\langle\finchdeclare(tns, init, dims...), (e, t)\rangle \rightarrow (e [\finchmode(tns) \mapsto update], \langle declare(tns', init', dims'...), t \rangle)}
\]
\[
\frac{s = (e, t) \quad e(\finchmode(tns)) = read \quad e(tns) = tns'}
{\langle\finchthaw(tns), (e, t)\rangle \rightarrow (e [\finchmode(tns) \mapsto update], \langle thaw(tns'), t \rangle)}
\]
\[
\frac{s = (e, t) \quad e(\finchmode(tns)) = update \quad e(tns) = tns'}
{\langle\finchfreeze(tns), (e, t)\rangle \rightarrow (e [\finchmode(tns) \mapsto read], \langle freeze(tns'), t \rangle)}
\]

$E$ is an evaluation context that applies anywhere in the syntax tree.

\[
\frac{e(tns) = tns' \langle unfurl(tns'), t\rangle \rightarrow \langle tns'', t'\rangle}
{\langle \finchloop(i, ext, E[\finchaccess(tns, j..., i)]), (e, t)\rangle \rightarrow \langle \finchloop(i, ext, E[\finchaccess(tns'', j..., i)]), (e, t')\rangle}
\]

\[
\frac{}
{\splitfrac{\langle \finchloop(i, ext, E[\finchaccess(run(body), j..., i)]), s\rangle
    }{\rightarrow \langle \finchloop(i, ext, E[\finchaccess(body, j...)]), s\rangle}}
\]

\[
\frac{e(i) = i' \quad \langle seek(i'), t \rangle \rightarrow t'}
{\splitfrac{\langle E[\finchaccess(lookup(seek, body), j..., i)], (e, t)\rangle
    }{\rightarrow \langle E[\finchaccess(body, j...)], (e, t')\rangle}}
\]

\[
\frac{\langle cond, t \rangle \Rightarrow true}
{\splitfrac{\langle E[\finchaccess(switch(cond, head, tail), i...)], s\rangle
    }{\rightarrow \langle E[\finchaccess(head, i...)], s\rangle}}
\]

\[
\frac{\langle cond, t \rangle \Rightarrow false}
{\splitfrac{\langle E[\finchaccess(switch(cond, head, tail), i...)], s\rangle
    }{\rightarrow \langle E[\finchaccess(tail, i...)], s\rangle}}
\]

\[
\frac{}
{\splitfrac{\langle \finchloop(i, extent(a, b), E[\finchaccess(phase(extent(c, d), body), j..., i)]), s\rangle
    }{\rightarrow \langle \finchloop(i, extent(max(a, c), min(b, d)), E[\finchaccess(body, j..., i)]), s\rangle}}
\]

\[
\frac{\langle \finchloop(i, ext, E[\finchaccess(head, j..., i)]), s\rangle \rightarrow s'}
{\splitfrac{\langle \finchloop(i, ext, E[\finchaccess(sequence(head, tail), j..., i)]), s\rangle
    }{\rightarrow \langle \finchloop(i, ext, E[\finchaccess(tail, j..., i)]), s'\rangle}}
\]

\[
\frac{\langle seek(a), t \rangle \rightarrow t' \quad }
{\splitfrac{\langle \finchloop(i, extent(a, b), E[\finchaccess(stepper(seek, body, next), j..., i)]), (e, t)\rangle
    }{\rightarrow \langle \finchloop(i, extent(a, b), E[\finchaccess(stepper(body, next), j..., i)]), (e, t')\rangle}}
\]

\[
\frac{\langle \finchloop(i, ext, E[\finchaccess(body, j..., i)]), (e, t) \rangle \rightarrow (e', t') \quad \langle next, t' \rangle \rightarrow t''}
{\splitfrac{\langle \finchloop(i, ext, E[\finchaccess(stepper(body, next), j..., i)]), s\rangle
    }{\rightarrow \langle \finchloop(i, ext, E[\finchaccess(thunk(next, stepper(body, next)), j..., i)]), (e', t'')\rangle}}
\]


\subsection{Wrapper Tensors}

\subsection{Scalars}

\subsubsection{Sparse Scalars}
\subsubsection{Early Break Scalars}

