Looplets provide descriptions of iterators. 
%
The Finch language provides descriptions of computations that iterate over a subset of a regular grid that is lexicographically ordered.
%
At this point, the reader might believe that compilation of a Finch program simply involves simply replacing for loops over a range with for loops over iterators, but Finch programs and data structures are sufficiently flexible that this impossible.
%
First, the Finch language interacts with multi-dimensional tensors whereas the Looplet abstraction is much easier to manage when considering a single dimensional iterator. 
%
We require a bridge between the single dimensional iterators created from looplets and the mutli-dimensional abstractions common to tensor compilers.
%
Second, since the iteration order of a Finch program might not match that of a data structure (a discordant traversal), different iterators need to be requested for the same data depending on the traversal order of the program.
%
So we require a bridge that can provide different iteration orders depending on the context.
%
Third, since Finch programs can read and write to the same data, multi-dimensional tensors need to provide iterators for reading and writing as well as machinery to manage transition between these states.

To build our bridge, we embrace a set of abstractions: level formats/Fiber Trees, iteration context dependent instantiation of iterators, and tensor life cycles.
%
Our first abstraction mostly already exists in the literature: a manner of specifying a data structure for a multi-dimensional tensor out of data structures for single dimensional tensors~\cite{sze2017efficient,chou2022compilation, chou2018format}. 
%
We recapitulate the essential details here.
%
Our second abstraction adds to to the first by providing a mechanism to use data structures generated by the first abstraction in a greater variety of contexts while maintaining per-dimension encapsulation and limiting the amount of specific work.
%
Previous efforts to compiler a greater variety of sparse tensor programs left this bridge untouched ~\cite{henry2021compilation, won2023unified}.
%
Our third abstraction limits our set of sparse tensor programs to accommodate a natural restriction on when multi-dimensional data structures can be modified.
%
% As we will see
% \begin{enumerate}
%     \item Compilation substitutes in different iterators depending on context, mainly the traversal pattern of the iterator (oh god).
%     \item Less obviously, iterators have other state that needs to be tracked, such as when we write stuff.
%     \item how do we ask for the right iterator and how do we change/manage their state?
% \end{enumerate}
% Need to Make these problems clear by this point, hope that read anticipate them.

% Solutions:
% \begin{enumerate}
%     \item Einsum like: limit when state can change, leading to a natural lifecycle for a tensor.
%     \item simple interface to go from an index expression into an iterator that decomposes in a way tensor compilers are used to.
% \end{enumerate}

\subsection{Level Abstraction}
    
\begin{enumerate}
\item fibers
\item assembly
\item reassembly
\end{enumerate}

\subsection{Instatiation Interface}

\subsection{Tensor Lifecycle, Declare, Freeze, Thaw, Unfurl}


\subsection{Core Level Language Primitives}
\begin{enumerate}
\item SparseList
\item SparseDict
\item ...
\end{enumerate}
